"""
üéØ ÏÜçÎã¥ Í≤åÏûÑ - Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò Î™®Îìà

Ïù¥ Î™®ÎìàÏùÄ ÏÜçÎã¥ ÎÇúÏù¥ÎèÑ Î∂ÑÏÑù ÏãúÏä§ÌÖúÏóêÏÑú ÏÇ¨Ïö©ÎêòÎäî 
Ïú†Ïö©Ìïú Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.

Ï£ºÏöî Í∏∞Îä•:
1. ÏÜçÎã¥ ÌÖçÏä§Ìä∏ Ï≤òÎ¶¨ Î∞è Í≤∞Ìï©
2. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Í≤ÄÏ¶ù
3. ÎÇúÏù¥ÎèÑ Î∂ÑÌè¨ Í≥ÑÏÇ∞ Î∞è ÌÜµÍ≥Ñ
4. Î∂ÑÏÑù Í≤∞Í≥º ÎÇ¥Î≥¥ÎÇ¥Í∏∞
5. ÏãúÏä§ÌÖú ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ

ÏÇ¨Ïö© ÏòàÏãú:
    from utils import combine_proverb_parts, validate_database_connection
    
    full_proverb = combine_proverb_parts("Í∞ÄÎäî ÎßêÏù¥ Í≥†ÏôÄÏïº", "Ïò§Îäî ÎßêÏù¥ Í≥±Îã§")
    is_connected = validate_database_connection()
"""

import os
import sys
import json
import csv
import traceback
from typing import Dict, List, Optional, Union, Any, Tuple
from datetime import datetime
import logging

# config Î∞è database Î™®Îìà import
try:
    import sys
    import os
    # ÌòÑÏû¨ ÌååÏùºÏùò Î∂ÄÎ™® ÎîîÎ†âÌÜ†Î¶¨Îì§ÏùÑ sys.pathÏóê Ï∂îÍ∞Ä
    current_dir = os.path.dirname(os.path.abspath(__file__))
    parent_dir = os.path.dirname(current_dir)  # app ÎîîÎ†âÌÜ†Î¶¨
    root_dir = os.path.dirname(parent_dir)     # ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏
    sys.path.insert(0, root_dir)
    
    from app.core.config import proverb_config
    from app.includes.dbconn import ProverbDatabase
except ImportError as e:
    print(f"‚ùå Î™®Îìà import Ïã§Ìå®: {e}")
    sys.exit(1)


def combine_proverb_parts(question: str, answer: str, separator: str = " ") -> str:
    """
    üîó ÏÜçÎã¥Ïùò ÏïûÎ∂ÄÎ∂ÑÍ≥º Îí∑Î∂ÄÎ∂ÑÏùÑ Ìï©Ï≥êÏÑú ÏôÑÏ†ÑÌïú ÏÜçÎã¥ÏùÑ ÎßåÎì≠ÎãàÎã§.
    
    Args:
        question: ÏÜçÎã¥ ÏïûÎ∂ÄÎ∂Ñ (Î¨∏Ï†ú)
        answer: ÏÜçÎã¥ Îí∑Î∂ÄÎ∂Ñ (Ï†ïÎãµ)
        separator: Ïó∞Í≤∞ Íµ¨Î∂ÑÏûê (Í∏∞Î≥∏: Í≥µÎ∞±)
        
    Returns:
        str: ÏôÑÏÑ±Îêú ÏÜçÎã¥
        
    Example:
        >>> combine_proverb_parts("Í∞ÄÎäî ÎßêÏù¥ Í≥†ÏôÄÏïº", "Ïò§Îäî ÎßêÏù¥ Í≥±Îã§")
        "Í∞ÄÎäî ÎßêÏù¥ Í≥†ÏôÄÏïº Ïò§Îäî ÎßêÏù¥ Í≥±Îã§"
    """
    if not question or not answer:
        return ""
    
    # Í≥µÎ∞± Ï†ïÎ¶¨
    question = question.strip()
    answer = answer.strip()
    
    if not question or not answer:
        return ""
    
    # ÏûêÏó∞Ïä§Îü¨Ïö¥ Ïó∞Í≤∞ÏùÑ ÏúÑÌïú Ï≤òÎ¶¨
    if question.endswith(('ÏùÄ', 'Îäî', 'Ïù¥', 'Í∞Ä', 'ÏùÑ', 'Î•º', 'Ïóê', 'ÏóêÏÑú', 'ÏúºÎ°ú', 'Î°ú', 'ÏôÄ', 'Í≥º')):
        return f"{question} {answer}"
    elif question.endswith(('ÌïòÎ©¥', 'Î©¥', 'Îãà', 'Ïïº')):
        return f"{question} {answer}"
    else:
        return f"{question}{separator}{answer}"


def validate_database_connection() -> Dict[str, Union[bool, str, int]]:
    """
    üóÑÔ∏è Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïú†Ìö®ÏÑ±ÏùÑ Í≤ÄÏÇ¨Ìï©ÎãàÎã§.
    
    Returns:
        Dict: Ïó∞Í≤∞ ÏÉÅÌÉú Ï†ïÎ≥¥
        {
            "success": True/False,
            "connected": True/False,
            "message": "Ïó∞Í≤∞ ÏÉÅÌÉú Î©îÏãúÏßÄ",
            "host": "localhost",
            "database": "proverb_game",
            "table_exists": True/False,
            "proverb_count": 90
        }
    """
    result = {
        "success": False,
        "connected": False,
        "message": "",
        "host": proverb_config.DB_HOST,
        "database": proverb_config.DB_NAME,
        "table_exists": False,
        "proverb_count": 0
    }
    
    try:
        print("üîç Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Í≤ÄÏ¶ù Ï§ë...")
        
        # Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ ÏãúÎèÑ
        db = ProverbDatabase()
        
        # Ïó∞Í≤∞ ÌÖåÏä§Ìä∏
        if not db.test_connection():
            result["message"] = "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïã§Ìå®"
            return result
        
        result["success"] = True
        result["connected"] = True
        
        # ÌÖåÏù¥Î∏î Ï°¥Ïû¨ ÌôïÏù∏
        table_exists = db.check_table_exists()
        result["table_exists"] = table_exists
        
        if table_exists:
            # ÏÜçÎã¥ Í∞úÏàò ÌôïÏù∏
            proverb_count = db.get_proverb_count()
            result["proverb_count"] = proverb_count
            result["message"] = f"Ïó∞Í≤∞ ÏÑ±Í≥µ - {proverb_count}Í∞ú ÏÜçÎã¥ ÌôïÏù∏"
        else:
            result["message"] = "Ïó∞Í≤∞ ÏÑ±Í≥µ - proverb ÌÖåÏù¥Î∏î ÏóÜÏùå"
        
        db.close()
        
        print(f"‚úÖ {result['message']}")
        return result
        
    except Exception as e:
        result["message"] = f"Í≤ÄÏ¶ù Ïã§Ìå®: {str(e)}"
        print(f"‚ùå {result['message']}")
        return result


def calculate_difficulty_distribution(analysis_results: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    üìä ÎÇúÏù¥ÎèÑ Î∂ÑÏÑù Í≤∞Í≥ºÏùò Î∂ÑÌè¨Î•º Í≥ÑÏÇ∞Ìï©ÎãàÎã§.
    
    Args:
        analysis_results: ÎÇúÏù¥ÎèÑ Î∂ÑÏÑù Í≤∞Í≥º Î™©Î°ù
        
    Returns:
        Dict: ÎÇúÏù¥ÎèÑ Î∂ÑÌè¨ ÌÜµÍ≥Ñ
        {
            "total_count": 90,
            "success_count": 87,
            "difficulty_distribution": {
                1: {"count": 30, "percentage": 34.5, "total_score": 30},
                2: {"count": 35, "percentage": 40.2, "total_score": 70}, 
                3: {"count": 22, "percentage": 25.3, "total_score": 66}
            },
            "average_difficulty": 1.9,
            "total_possible_score": 166,
            "confidence_stats": {
                "average": 0.72,
                "min": 0.45,
                "max": 0.95
            }
        }
    """
    if not analysis_results:
        return {"error": "Î∂ÑÏÑù Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§"}
    
    print("üìä ÎÇúÏù¥ÎèÑ Î∂ÑÌè¨ Í≥ÑÏÇ∞ Ï§ë...")
    
    # ÏÑ±Í≥µÏ†ÅÏù∏ Î∂ÑÏÑù Í≤∞Í≥ºÎßå ÌïÑÌÑ∞ÎßÅ
    success_results = [r for r in analysis_results if r.get('difficulty_level', 0) > 0]
    
    # Í∏∞Î≥∏ ÌÜµÍ≥Ñ
    total_count = len(analysis_results)
    success_count = len(success_results)
    
    if success_count == 0:
        return {
            "total_count": total_count,
            "success_count": 0,
            "error": "ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î∂ÑÏÑùÎêú Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§"
        }
    
    # ÎÇúÏù¥ÎèÑÎ≥Ñ Î∂ÑÌè¨ Í≥ÑÏÇ∞
    difficulty_distribution = {}
    difficulty_levels = [1, 2, 3]
    confidence_scores = []
    total_score = 0
    difficulty_sum = 0
    
    for level in difficulty_levels:
        level_results = [r for r in success_results if r.get('difficulty_level') == level]
        count = len(level_results)
        percentage = (count / success_count) * 100 if success_count > 0 else 0
        level_total_score = count * level  # Í∞Å Î†àÎ≤®Ïùò Ï†êÏàòÎäî Î†àÎ≤® Î≤àÌò∏ÏôÄ Í∞ôÏùå
        
        difficulty_distribution[level] = {
            "count": count,
            "percentage": round(percentage, 1),
            "total_score": level_total_score
        }
        
        total_score += level_total_score
        difficulty_sum += level * count
        
        # Ìï¥Îãπ Î†àÎ≤®Ïùò Ïã†Î¢∞ÎèÑ Ï†êÏàò ÏàòÏßë
        level_confidences = [r.get('confidence', 0) for r in level_results]
        confidence_scores.extend(level_confidences)
    
    # ÌèâÍ∑† ÎÇúÏù¥ÎèÑ Í≥ÑÏÇ∞
    average_difficulty = difficulty_sum / success_count if success_count > 0 else 0
    
    # Ïã†Î¢∞ÎèÑ ÌÜµÍ≥Ñ
    confidence_stats = {}
    if confidence_scores:
        confidence_stats = {
            "average": round(sum(confidence_scores) / len(confidence_scores), 3),
            "min": round(min(confidence_scores), 3),
            "max": round(max(confidence_scores), 3)
        }
    
    distribution = {
        "total_count": total_count,
        "success_count": success_count,
        "success_rate": round((success_count / total_count) * 100, 1) if total_count > 0 else 0,
        "difficulty_distribution": difficulty_distribution,
        "average_difficulty": round(average_difficulty, 2),
        "total_possible_score": total_score,
        "confidence_stats": confidence_stats
    }
    
    print(f"‚úÖ ÎÇúÏù¥ÎèÑ Î∂ÑÌè¨ Í≥ÑÏÇ∞ ÏôÑÎ£å:")
    print(f"  - Ï†ÑÏ≤¥: {total_count}Í∞ú, ÏÑ±Í≥µ: {success_count}Í∞ú ({distribution['success_rate']}%)")
    print(f"  - ÌèâÍ∑† ÎÇúÏù¥ÎèÑ: {average_difficulty:.2f}")
    print(f"  - Ï¥ù Ï†êÏàò: {total_score}Ï†ê")
    
    return distribution


def export_analysis_results(results: List[Dict[str, Any]], 
                          output_format: str = "json",
                          output_path: Optional[str] = None) -> str:
    """
    üì§ Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÌååÏùºÎ°ú ÎÇ¥Î≥¥ÎÉÖÎãàÎã§.
    
    Args:
        results: Î∂ÑÏÑù Í≤∞Í≥º Î™©Î°ù
        output_format: Ï∂úÎ†• ÌòïÏãù ("json", "csv")
        output_path: Ï∂úÎ†• ÌååÏùº Í≤ΩÎ°ú (NoneÏù¥Î©¥ ÏûêÎèô ÏÉùÏÑ±)
        
    Returns:
        str: ÏÉùÏÑ±Îêú ÌååÏùº Í≤ΩÎ°ú
        
    Example:
        >>> export_path = export_analysis_results(results, "json")
        >>> print(f"Í≤∞Í≥ºÎ•º {export_path}Ïóê Ï†ÄÏû•ÌñàÏäµÎãàÎã§")
    """
    if not results:
        raise ValueError("ÎÇ¥Î≥¥ÎÇº Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§")
    
    # Ï∂úÎ†• ÎîîÎ†âÌÜ†Î¶¨ ÏÑ§Ï†ï
    output_dir = os.path.join(proverb_config.BASE_DIR, "exports")
    os.makedirs(output_dir, exist_ok=True)
    
    # ÌååÏùºÎ™Ö ÏûêÎèô ÏÉùÏÑ±
    if not output_path:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"proverb_analysis_{timestamp}.{output_format.lower()}"
        output_path = os.path.join(output_dir, filename)
    
    print(f"üì§ Î∂ÑÏÑù Í≤∞Í≥º ÎÇ¥Î≥¥ÎÇ¥Í∏∞: {output_format.upper()} ÌòïÏãù")
    print(f"üìÅ Ï∂úÎ†• Í≤ΩÎ°ú: {output_path}")
    
    try:
        if output_format.lower() == "json":
            # JSON ÌòïÏãùÏúºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞
            export_data = {
                "export_info": {
                    "timestamp": datetime.now().isoformat(),
                    "total_count": len(results),
                    "success_count": len([r for r in results if r.get('difficulty_level', 0) > 0]),
                    "format": "json"
                },
                "difficulty_levels": proverb_config.PROVERB_DIFFICULTY_LEVELS,
                "analysis_results": results
            }
            
            with open(output_path, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, ensure_ascii=False, indent=2)
        
        elif output_format.lower() == "csv":
            # CSV ÌòïÏãùÏúºÎ°ú ÎÇ¥Î≥¥ÎÇ¥Í∏∞
            fieldnames = [
                'proverb_id', 'full_proverb', 'difficulty_level', 
                'confidence', 'score', 'processing_time', 'message'
            ]
            
            with open(output_path, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                
                for result in results:
                    row = {field: result.get(field, '') for field in fieldnames}
                    writer.writerow(row)
        
        else:
            raise ValueError(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌòïÏãù: {output_format}")
        
        file_size = os.path.getsize(output_path)
        print(f"‚úÖ ÎÇ¥Î≥¥ÎÇ¥Í∏∞ ÏôÑÎ£å: {output_path} ({file_size:,} bytes)")
        
        return output_path
        
    except Exception as e:
        print(f"‚ùå ÎÇ¥Î≥¥ÎÇ¥Í∏∞ Ïã§Ìå®: {str(e)}")
        raise


def print_analysis_summary_table(results: List[Dict[str, Any]], 
                                max_rows: int = 20) -> None:
    """
    üìã Î∂ÑÏÑù Í≤∞Í≥ºÎ•º ÌÖåÏù¥Î∏î ÌòïÌÉúÎ°ú Ï∂úÎ†•Ìï©ÎãàÎã§.
    
    Args:
        results: Î∂ÑÏÑù Í≤∞Í≥º Î™©Î°ù
        max_rows: ÏµúÎåÄ Ï∂úÎ†• Ìñâ Ïàò
    """
    if not results:
        print("‚ùå Ï∂úÎ†•Ìï† Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§")
        return
    
    # ÏÑ±Í≥µÏ†ÅÏù∏ Í≤∞Í≥ºÎßå ÌïÑÌÑ∞ÎßÅ
    success_results = [r for r in results if r.get('difficulty_level', 0) > 0]
    
    if not success_results:
        print("‚ùå ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î∂ÑÏÑùÎêú Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§")
        return
    
    print(f"\nüìã Î∂ÑÏÑù Í≤∞Í≥º ÏöîÏïΩ ÌÖåÏù¥Î∏î (ÏÉÅÏúÑ {min(max_rows, len(success_results))}Í∞ú)")
    print("=" * 100)
    
    # Ìó§Îçî Ï∂úÎ†•
    header = f"{'ID':<4} {'ÏÜçÎã¥':<40} {'ÎÇúÏù¥ÎèÑ':<10} {'Ï†êÏàò':<4} {'Ïã†Î¢∞ÎèÑ':<8} {'ÏãúÍ∞Ñ':<8}"
    print(header)
    print("-" * 100)
    
    # Îç∞Ïù¥ÌÑ∞ Ï∂úÎ†•
    for i, result in enumerate(success_results[:max_rows]):
        proverb_id = result.get('proverb_id', 'N/A')
        full_proverb = result.get('full_proverb', '')
        
        # ÏÜçÎã¥ ÌÖçÏä§Ìä∏ Í∏∏Ïù¥ Ï†úÌïú
        if len(full_proverb) > 35:
            proverb_display = full_proverb[:32] + "..."
        else:
            proverb_display = full_proverb
        
        difficulty_level = result.get('difficulty_level', 0)
        level_info = proverb_config.PROVERB_DIFFICULTY_LEVELS.get(difficulty_level, {})
        level_name = level_info.get('name', 'Ïïå Ïàò ÏóÜÏùå')
        
        score = result.get('score', 0)
        confidence = result.get('confidence', 0.0)
        processing_time = result.get('processing_time', 0.0)
        
        row = f"{proverb_id:<4} {proverb_display:<40} {level_name:<10} {score:<4} {confidence:<8.1%} {processing_time:<8.3f}"
        print(row)
    
    # ÏöîÏïΩ ÌÜµÍ≥Ñ
    if len(success_results) > max_rows:
        print(f"\n... Î∞è {len(success_results) - max_rows}Í∞ú Îçî")
    
    # Î∂ÑÌè¨ ÏöîÏïΩ
    distribution = calculate_difficulty_distribution(results)
    print(f"\nüìä ÏöîÏïΩ:")
    print(f"  - Ï†ÑÏ≤¥: {distribution['total_count']}Í∞ú")
    print(f"  - ÏÑ±Í≥µ: {distribution['success_count']}Í∞ú ({distribution['success_rate']}%)")
    print(f"  - ÌèâÍ∑† ÎÇúÏù¥ÎèÑ: {distribution['average_difficulty']}")
    print(f"  - Ï¥ù Ï†êÏàò: {distribution['total_possible_score']}Ï†ê")
    print("=" * 100)


def get_system_status() -> Dict[str, Any]:
    """
    üñ•Ô∏è ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.
    
    Returns:
        Dict: ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï†ïÎ≥¥
    """
    try:
        import psutil
        import torch
        
        # ÏãúÏä§ÌÖú Ï†ïÎ≥¥
        memory = psutil.virtual_memory()
        cpu_percent = psutil.cpu_percent(interval=1)
        
        status = {
            "timestamp": datetime.now().isoformat(),
            "system": {
                "cpu_percent": cpu_percent,
                "memory_total": f"{memory.total / (1024**3):.1f} GB",
                "memory_used": f"{memory.used / (1024**3):.1f} GB",
                "memory_percent": memory.percent
            },
            "ai_model": {
                "name": proverb_config.MODEL_NAME,
                "device": proverb_config.DEVICE,
                "cache_dir": proverb_config.MODEL_CACHE_DIR
            },
            "database": validate_database_connection(),
            "config": {
                "batch_size": proverb_config.BATCH_SIZE_ANALYSIS,
                "caching_enabled": proverb_config.ENABLE_CACHING,
                "difficulty_levels": len(proverb_config.PROVERB_DIFFICULTY_LEVELS)
            }
        }
        
        # GPU Ï†ïÎ≥¥ (ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Í≤ΩÏö∞)
        if torch.cuda.is_available():
            status["system"]["gpu_available"] = True
            status["system"]["gpu_name"] = torch.cuda.get_device_name(0)
            status["system"]["gpu_memory_allocated"] = f"{torch.cuda.memory_allocated() / (1024**2):.1f} MB"
        else:
            status["system"]["gpu_available"] = False
        
        return status
        
    except Exception as e:
        return {
            "error": f"ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï°∞Ìöå Ïã§Ìå®: {str(e)}",
            "timestamp": datetime.now().isoformat()
        }


def cleanup_cache_files(cache_dir: Optional[str] = None, 
                       max_age_days: int = 30) -> Dict[str, Any]:
    """
    üóëÔ∏è Ïò§ÎûòÎêú Ï∫êÏãú ÌååÏùºÎì§ÏùÑ Ï†ïÎ¶¨Ìï©ÎãàÎã§.
    
    Args:
        cache_dir: Ï∫êÏãú ÎîîÎ†âÌÜ†Î¶¨ (NoneÏù¥Î©¥ Í∏∞Î≥∏ Ï∫êÏãú ÎîîÎ†âÌÜ†Î¶¨ ÏÇ¨Ïö©)
        max_age_days: ÏµúÎåÄ Î≥¥Í¥Ä ÏùºÏàò
        
    Returns:
        Dict: Ï†ïÎ¶¨ Í≤∞Í≥º
    """
    if not cache_dir:
        cache_dir = proverb_config.MODEL_CACHE_DIR
    
    if not os.path.exists(cache_dir):
        return {"message": "Ï∫êÏãú ÎîîÎ†âÌÜ†Î¶¨Í∞Ä Ï°¥Ïû¨ÌïòÏßÄ ÏïäÏäµÎãàÎã§"}
    
    import time
    from pathlib import Path
    
    current_time = time.time()
    max_age_seconds = max_age_days * 24 * 60 * 60
    
    cleaned_files = []
    total_size_freed = 0
    
    try:
        for file_path in Path(cache_dir).rglob("*"):
            if file_path.is_file():
                file_age = current_time - file_path.stat().st_mtime
                
                if file_age > max_age_seconds:
                    file_size = file_path.stat().st_size
                    file_path.unlink()
                    
                    cleaned_files.append({
                        "path": str(file_path),
                        "size": file_size,
                        "age_days": file_age / (24 * 60 * 60)
                    })
                    
                    total_size_freed += file_size
        
        result = {
            "cleaned_files_count": len(cleaned_files),
            "total_size_freed": f"{total_size_freed / (1024**2):.1f} MB",
            "max_age_days": max_age_days,
            "cache_dir": cache_dir
        }
        
        if cleaned_files:
            print(f"üóëÔ∏è Ï∫êÏãú Ï†ïÎ¶¨ ÏôÑÎ£å: {len(cleaned_files)}Í∞ú ÌååÏùº, {result['total_size_freed']} ÌôïÎ≥¥")
        else:
            print(f"‚úÖ Ï†ïÎ¶¨Ìï† Ï∫êÏãú ÌååÏùºÏù¥ ÏóÜÏäµÎãàÎã§")
        
        return result
        
    except Exception as e:
        return {"error": f"Ï∫êÏãú Ï†ïÎ¶¨ Ïã§Ìå®: {str(e)}"}


def test_all_utilities():
    """
    üß™ Î™®Îì† Ïú†Ìã∏Î¶¨Ìã∞ Ìï®ÏàòÎì§ÏùÑ ÌÖåÏä§Ìä∏Ìï©ÎãàÎã§.
    """
    print("üß™ Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò Ï¢ÖÌï© ÌÖåÏä§Ìä∏ ÏãúÏûë")
    print("=" * 60)
    
    test_results = []
    
    # 1. ÏÜçÎã¥ Í≤∞Ìï© ÌÖåÏä§Ìä∏
    try:
        print("\n1. ÏÜçÎã¥ Í≤∞Ìï© ÌÖåÏä§Ìä∏:")
        combined = combine_proverb_parts("Í∞ÄÎäî ÎßêÏù¥ Í≥†ÏôÄÏïº", "Ïò§Îäî ÎßêÏù¥ Í≥±Îã§")
        print(f"   Í≤∞Í≥º: '{combined}'")
        test_results.append(("ÏÜçÎã¥ Í≤∞Ìï©", True, ""))
    except Exception as e:
        print(f"   ‚ùå Ïã§Ìå®: {str(e)}")
        test_results.append(("ÏÜçÎã¥ Í≤∞Ìï©", False, str(e)))
    
    # 2. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Í≤ÄÏ¶ù ÌÖåÏä§Ìä∏
    try:
        print("\n2. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Í≤ÄÏ¶ù:")
        db_status = validate_database_connection()
        print(f"   Ïó∞Í≤∞ ÏÉÅÌÉú: {db_status['connected']}")
        print(f"   Î©îÏãúÏßÄ: {db_status['message']}")
        test_results.append(("DB Ïó∞Í≤∞ Í≤ÄÏ¶ù", db_status['connected'], db_status['message']))
    except Exception as e:
        print(f"   ‚ùå Ïã§Ìå®: {str(e)}")
        test_results.append(("DB Ïó∞Í≤∞ Í≤ÄÏ¶ù", False, str(e)))
    
    # 3. ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï°∞Ìöå ÌÖåÏä§Ìä∏
    try:
        print("\n3. ÏãúÏä§ÌÖú ÏÉÅÌÉú Ï°∞Ìöå:")
        system_status = get_system_status()
        if 'error' not in system_status:
            print(f"   CPU ÏÇ¨Ïö©Î•†: {system_status['system']['cpu_percent']}%")
            print(f"   Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Î•†: {system_status['system']['memory_percent']}%")
            print(f"   AI Î™®Îç∏: {system_status['ai_model']['name']}")
            test_results.append(("ÏãúÏä§ÌÖú ÏÉÅÌÉú", True, ""))
        else:
            print(f"   ‚ùå {system_status['error']}")
            test_results.append(("ÏãúÏä§ÌÖú ÏÉÅÌÉú", False, system_status['error']))
    except Exception as e:
        print(f"   ‚ùå Ïã§Ìå®: {str(e)}")
        test_results.append(("ÏãúÏä§ÌÖú ÏÉÅÌÉú", False, str(e)))
    
    # 4. ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ
    print(f"\nüìä ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ:")
    print("-" * 40)
    
    success_count = 0
    for test_name, success, message in test_results:
        status = "‚úÖ ÏÑ±Í≥µ" if success else "‚ùå Ïã§Ìå®"
        print(f"{status} - {test_name}")
        if not success and message:
            print(f"        {message}")
        if success:
            success_count += 1
    
    print(f"\nÏ†ÑÏ≤¥ Í≤∞Í≥º: {success_count}/{len(test_results)} ÌÖåÏä§Ìä∏ ÌÜµÍ≥º")
    
    return success_count == len(test_results)


if __name__ == "__main__":
    """
    üöÄ Ïä§ÌÅ¨Î¶ΩÌä∏ ÏßÅÏ†ë Ïã§Ìñâ Ïãú ÌÖåÏä§Ìä∏ Ìï®Ïàò Ìò∏Ï∂ú
    
    Ïã§Ìñâ Î∞©Î≤ï:
        python utils.py
    """
    print("üõ†Ô∏è ÏÜçÎã¥ Í≤åÏûÑ - Ïú†Ìã∏Î¶¨Ìã∞ Ìï®Ïàò ÌÖåÏä§Ìä∏")
    print("Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞, ÌÖçÏä§Ìä∏ Ï≤òÎ¶¨, ÏãúÏä§ÌÖú ÏÉÅÌÉú Îì±")
    print()
    
    success = test_all_utilities()
    sys.exit(0 if success else 1)
